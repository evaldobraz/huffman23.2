{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment DOCUMENTA\'C7\'C3O HUFFMAN  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}DOCUMENTA\'C7\'C3O HUFFMAN}
{\comment Gerado por doxygen 1.10.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt DOCUMENTA\'C7\'C3O HUFFMAN}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 1.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice das Estruturas de Dados\par \pard\plain 
{\tc \v \'CDndice das Estruturas de Dados}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Estruturas de Dados\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Aqui est\'E3o as estruturas de dados, uni\'F5es e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b data} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b map} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b node} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Arquivos\par \pard\plain 
{\tc \v \'CDndice dos Arquivos}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Arquivos\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta \'E9 a lista de todos os arquivos e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b c\'F3digo/{\b common.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b c\'F3digo/{\b common.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b c\'F3digo/{\b compress.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b c\'F3digo/{\b compress.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b c\'F3digo/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b c\'F3digo/{\b uncompress.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b c\'F3digo/{\b uncompress.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Estruturas{\tc \v Estruturas}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura data\par \pard\plain 
{\tc\tcl2 \v data}
{\xe \v data}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\par
{
{\f2 #include <common.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Campos de Dados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b unsigned} {\b char} {\b byte}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b frequency}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Campos\par
\pard\plain 
{\xe \v byte\:data}
{\xe \v data\:byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b unsigned} {\b char} data::byte}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v frequency\:data}
{\xe \v data\:frequency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long data::frequency}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
c\'F3digo/{\b common.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura map\par \pard\plain 
{\tc\tcl2 \v map}
{\xe \v map}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\par
{
{\f2 #include <common.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Campos de Dados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
short {\b symbol_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b symbol}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Campos\par
\pard\plain 
{\xe \v symbol\:map}
{\xe \v map\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long map::symbol}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v symbol_size\:map}
{\xe \v map\:symbol_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
short map::symbol_size}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
c\'F3digo/{\b common.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura node\par \pard\plain 
{\tc\tcl2 \v node}
{\xe \v node}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\par
{
{\f2 #include <common.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Campos de Dados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b data}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b node} * {\b next}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b node} * {\b left}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b node} * {\b right}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Campos\par
\pard\plain 
{\xe \v data\:node}
{\xe \v node\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* node::data}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v left\:node}
{\xe \v node\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b node}* node::left}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v next\:node}
{\xe \v node\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b node}* node::next}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v right\:node}
{\xe \v node\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b node}* node::right}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
c\'F3digo/{\b common.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Arquivos{\tc \v Arquivos}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo c\'F3digo/common.c\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/common.c}
{\xe \v c\'F3digo/common.c}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "common.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b set_bit} (unsigned char byte, int bit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_bit_set} (unsigned char byte, int bit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b left_shift} (unsigned char byte, int shift_ammout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b right_shift} (unsigned char byte, int shift_ammout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b create_output_file} (char *file_name, short operation)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v create_output_file\:common.c}
{\xe \v common.c\:create_output_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE * create_output_file (char *  {\i file_name}, short  {\i operation})}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27     FILE *output;\par
28     {\cf18 char} output_file_name[MAX_FNAME];\par
29     {\cf19 switch} (operation)\par
30     \{\par
31         {\cf19 case} COMPRESS:\par
32             sprintf(output_file_name, {\cf22 "%s.huff"}, file_name);\par
33             output = fopen(output_file_name, {\cf22 "wb"});\par
34             {\cf19 break};\par
35         {\cf19 case} UNCOMPRESS:\par
36             {\cf18 int} size = strlen(file_name) - 5;\par
37             file_name[size] = {\cf23 '\\0'};\par
38             sprintf(output_file_name, {\cf22 "%s"}, file_name);\par
39             output = fopen(output_file_name, {\cf22 "wb"});\par
40             {\cf19 break};\par
41     \}\par
42     {\cf19 return} output;\par
43 \}\par
}
}
{\xe \v is_bit_set\:common.c}
{\xe \v common.c\:is_bit_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_bit_set (unsigned char  {\i byte}, int  {\i bit})}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10 \{\par
11     {\cf18 unsigned} {\cf18 char} mask = 1<<bit;\par
12     {\cf19 return} {\cf18 byte} & mask;\par
13 \}\par
}
}
{\xe \v left_shift\:common.c}
{\xe \v common.c\:left_shift}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char left_shift (unsigned char  {\i byte}, int  {\i shift_ammout})}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16 \{\par
17     {\cf19 return} {\cf18 byte} << shift_ammout;\par
18 \}\par
}
}
{\xe \v right_shift\:common.c}
{\xe \v common.c\:right_shift}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char right_shift (unsigned char  {\i byte}, int  {\i shift_ammout})}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 \{\par
22     {\cf19 return} {\cf18 byte} >> shift_ammout;\par
23 \}\par
}
}
{\xe \v set_bit\:common.c}
{\xe \v common.c\:set_bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char set_bit (unsigned char  {\i byte}, int  {\i bit})}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4 \{\par
5     {\cf18 unsigned} {\cf18 char} mask = 1<<bit;\par
6     {\cf19 return} {\cf18 byte} | mask;\par
7 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo c\'F3digo/common.h\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/common.h}
{\xe \v c\'F3digo/common.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Estruturas de Dados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b node}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b data}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b map}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_FNAME}\~ 256\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPRESS}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNCOMPRESS}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PO_TREE_SCAPE}\~ 92\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b map} {\b dictionary}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct node {\b node}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct data {\b data}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b set_bit} (unsigned char byte, int bit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b unset_bit} (unsigned char byte, int bit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_bit_set} (unsigned char byte, int bit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b left_shift} (unsigned char byte, int shift_ammout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b right_shift} (unsigned char byte, int shift_ammout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b create_output_file} (char *file_name, short operation)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v COMPRESS\:common.h}
{\xe \v common.h\:COMPRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPRESS\~ 1}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MAX_FNAME\:common.h}
{\xe \v common.h\:MAX_FNAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_FNAME\~ 256}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PO_TREE_SCAPE\:common.h}
{\xe \v common.h\:PO_TREE_SCAPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PO_TREE_SCAPE\~ 92}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UNCOMPRESS\:common.h}
{\xe \v common.h\:UNCOMPRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNCOMPRESS\~ 2}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v data\:common.h}
{\xe \v common.h\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct data data}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dictionary\:common.h}
{\xe \v common.h\:dictionary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b map} {\b dictionary}}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v node\:common.h}
{\xe \v common.h\:node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct node node}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v create_output_file\:common.h}
{\xe \v common.h\:create_output_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE * create_output_file (char *  {\i file_name}, short  {\i operation})}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27     FILE *output;\par
28     {\cf18 char} output_file_name[MAX_FNAME];\par
29     {\cf19 switch} (operation)\par
30     \{\par
31         {\cf19 case} COMPRESS:\par
32             sprintf(output_file_name, {\cf22 "%s.huff"}, file_name);\par
33             output = fopen(output_file_name, {\cf22 "wb"});\par
34             {\cf19 break};\par
35         {\cf19 case} UNCOMPRESS:\par
36             {\cf18 int} size = strlen(file_name) - 5;\par
37             file_name[size] = {\cf23 '\\0'};\par
38             sprintf(output_file_name, {\cf22 "%s"}, file_name);\par
39             output = fopen(output_file_name, {\cf22 "wb"});\par
40             {\cf19 break};\par
41     \}\par
42     {\cf19 return} output;\par
43 \}\par
}
}
{\xe \v is_bit_set\:common.h}
{\xe \v common.h\:is_bit_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_bit_set (unsigned char  {\i byte}, int  {\i bit})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10 \{\par
11     {\cf18 unsigned} {\cf18 char} mask = 1<<bit;\par
12     {\cf19 return} {\cf18 byte} & mask;\par
13 \}\par
}
}
{\xe \v left_shift\:common.h}
{\xe \v common.h\:left_shift}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char left_shift (unsigned char  {\i byte}, int  {\i shift_ammout})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16 \{\par
17     {\cf19 return} {\cf18 byte} << shift_ammout;\par
18 \}\par
}
}
{\xe \v right_shift\:common.h}
{\xe \v common.h\:right_shift}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char right_shift (unsigned char  {\i byte}, int  {\i shift_ammout})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 \{\par
22     {\cf19 return} {\cf18 byte} >> shift_ammout;\par
23 \}\par
}
}
{\xe \v set_bit\:common.h}
{\xe \v common.h\:set_bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char set_bit (unsigned char  {\i byte}, int  {\i bit})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4 \{\par
5     {\cf18 unsigned} {\cf18 char} mask = 1<<bit;\par
6     {\cf19 return} {\cf18 byte} | mask;\par
7 \}\par
}
}
{\xe \v unset_bit\:common.h}
{\xe \v common.h\:unset_bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char unset_bit (unsigned char  {\i byte}, int  {\i bit})}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
common.h\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/common.h}
{\xe \v c\'F3digo/common.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef COMMON_H_INCLUDED}\par
2 {\cf21 #define COMMON_H_INCLUDED}\par
3 \par
4 {\cf21 #include <stdio.h>}\par
5 {\cf21 #include <stdlib.h>}\par
6 {\cf21 #include <stdbool.h>}\par
7 {\cf21 #include <string.h>}\par
8 \par
9 {\cf21 #define MAX_FNAME 256}\par
10 {\cf21 #define COMPRESS 1}\par
11 {\cf21 #define UNCOMPRESS 2}\par
12 {\cf21 #define PO_TREE_SCAPE 92 }{\cf20 //s\'EDmbolo de escape da impressao em pr\'E9-ordem d\'E1 \'E1rvore}\par
13 \par
14 {\cf17 typedef} {\cf17 struct }map dictionary;\par
15 {\cf17 typedef} {\cf17 struct }node node;\par
16 {\cf17 typedef} {\cf17 struct }data data;\par
17 \par
18 {\cf17 struct }node\{\par
19     {\cf18 void} *data;\par
20     node *next;\par
21     node *left;\par
22     node *right;\par
23 \};\par
24 \par
25 {\cf17 struct }data\{\par
26     {\cf18 unsigned} {\cf18 char} byte;\par
27     {\cf18 long} frequency;\par
28 \};\par
29 \par
30 {\cf17 struct }map\par
31 \{\par
32     {\cf18 short} symbol_size;\par
33     {\cf18 unsigned} {\cf18 long} symbol;\par
34 \};\par
35 \par
36 {\cf18 unsigned} {\cf18 char} set_bit({\cf18 unsigned} {\cf18 char} {\cf18 byte}, {\cf18 int} bit);\par
37 {\cf18 unsigned} {\cf18 char} unset_bit({\cf18 unsigned} {\cf18 char} {\cf18 byte}, {\cf18 int} bit);\par
38 {\cf18 bool} is_bit_set({\cf18 unsigned} {\cf18 char} {\cf18 byte}, {\cf18 int} bit);\par
39 {\cf18 unsigned} {\cf18 char} left_shift({\cf18 unsigned} {\cf18 char} {\cf18 byte}, {\cf18 int} shift_ammout);\par
40 {\cf18 unsigned} {\cf18 char} right_shift({\cf18 unsigned} {\cf18 char} {\cf18 byte}, {\cf18 int} shift_ammout);\par
41 FILE* create_output_file({\cf18 char} *file_name, {\cf18 short} operation);\par
42 \par
43 {\cf21 #endif }{\cf20 //COMMON_H_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo c\'F3digo/compress.c\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/compress.c}
{\xe \v c\'F3digo/compress.c}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "common.h"}\par
{\f2 #include "compress.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enqueue} ({\b node} **queue, {\b node} *left, {\b node} *right, unsigned char byte, int priority)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_bytes} (int *bytes_freq, FILE *input)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_priority_queue} ({\b node} **queue, int *bytes_freq)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_huffman_tree} ({\b node} **queue)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_pre_order_tree} ({\b node} *root, FILE *output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b get_tree_size} ({\b node} *root, int *size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b int_to_byte} (int tree_size, int trash_size, unsigned char trash_tree_size[2])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b compress} ({\b dictionary} bytes_map[256], {\b node} *root, FILE *input, FILE *output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b remap} ({\b node} *root, {\b dictionary} bytes_map[256], unsigned long new_symbol, int i, int bit)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v compress\:compress.c}
{\xe \v compress.c\:compress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void compress ({\b dictionary}  {\i bytes_map}[256], {\b node} *  {\i root}, FILE *  {\i input}, FILE *  {\i output})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 137 \{\par
138     {\cf18 unsigned} {\cf18 char} new_byte = {\cf23 '\\0'}, original_byte;\par
139     {\cf18 short} free_bits = 8, new_symbol_size=0;\par
140     dictionary new_symbol;\par
141     fwrite(&new_byte, 1, 2, output); {\cf20 //deixa dois bytes livres no come\'E7o de output para as informa\'E7\'F5es acerca do tamanho do lixo e da \'E1rvore.}\par
142     write_pre_order_tree(root, output); {\cf20 //escreve os bytes da \'E1rvore em pr\'E9 ordem}\par
143     \par
144     {\cf20 //loop para compactar os arquivos com os novos simbolos    }\par
145     {\cf19 while}(1) \par
146     \{\par
147         {\cf19 if}(new_symbol_size == 0 && !(feof(input)))\par
148         \{\par
149             fread(&original_byte, 1, 1, input); {\cf20 //l\'EA um byte do arquivo de entrada e salva ele em original_byte}\par
150             new_symbol = bytes_map[original_byte];\par
151             new_symbol_size = new_symbol.symbol_size;\par
152         \}\par
153 \par
154         {\cf19 if}(!feof(input) && free_bits == 0) {\cf20 //quando esgota os bits livres de new_byte escreve ele no arquivo e reinicia para escrever o resto do new_symbol.byte}\par
155         \{\par
156             fwrite(&new_byte, 1, 1, output);\par
157             new_byte = {\cf23 '\\0'};\par
158             free_bits = 8;\par
159         \}\par
160         {\cf19 else} {\cf19 if}(feof(input))\par
161         \{\par
162             fwrite(&new_byte, 1, 1, output);\par
163             {\cf19 break};\par
164         \}\par
165 \par
166         {\cf19 if}(new_symbol.symbol & (1UL << (new_symbol_size-1)))\par
167         \{\par
168             new_byte = set_bit(new_byte, free_bits-1);\par
169         \}\par
170 \par
171         free_bits--;\par
172         new_symbol_size--;\par
173     \}\par
174     \par
175     {\cf18 unsigned} {\cf18 char} trash_tree_size[2] = \{{\cf23 '\\0'}\};\par
176     {\cf18 int} tree_size = 0;\par
177     get_tree_size(root, &tree_size);\par
178     int_to_byte(tree_size, free_bits, trash_tree_size);\par
179     fseek(output, 0, SEEK_SET);\par
180     fwrite(trash_tree_size, 1, 2, output);\par
181 \}\par
}
}
{\xe \v create_huffman_tree\:compress.c}
{\xe \v compress.c\:create_huffman_tree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_huffman_tree ({\b node} **  {\i queue})}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 82 \{\par
83     {\cf19 while} ((*queue)->next != NULL) {\cf20 //navega na fila para transformar ela em \'E1rvore}\par
84     \{\par
85         {\cf20 //pega dois elementos de menor prioridade}\par
86         {\cf18 int} priority;\par
87         node *left = *queue;\par
88         *queue = (*queue)->next;\par
89         node *right = *queue;\par
90         *queue = (*queue)->next;\par
91         \par
92         {\cf17 struct }data *left_data = (data*)left->data;\par
93         {\cf17 struct }data *right_data = (data*)right->data;\par
94 \par
95         priority = left_data->frequency + right_data->frequency; {\cf20 //a frequencia do n\'F3 pai ser\'E1 a soma da frequencia dos dois n\'F3s filhos}\par
96         enqueue(queue, left, right, {\cf23 '*'}, priority); {\cf20 //cria um n\'F3 pai com os filhos sendo os dois menores, remove eles da fila e enfileira o n\'F3 pai}\par
97     \}\par
98 \}\par
}
}
{\xe \v create_priority_queue\:compress.c}
{\xe \v compress.c\:create_priority_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_priority_queue ({\b node} **  {\i queue}, int *  {\i bytes_freq})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58 \{\par
59     {\cf18 int} i, j;\par
60     {\cf19 for}(i=0; i<256; i++) {\cf20 //percorre a lista de frequencias 256 vezes (a quantidade de bytes poss\'EDveis)}\par
61     \{\par
62         {\cf18 int} priority=0, byte_index;\par
63         {\cf19 for}(j=0; j<256; j++) {\cf20 //percorre o a lista de frequencia dos bytes procurando a maior frequencia}\par
64         \{\par
65             {\cf19 if}(bytes_freq[j] >= priority && bytes_freq[j] > 0)\par
66             \{\par
67                 byte_index = j;\par
68                 priority = bytes_freq[j];\par
69             \}\par
70         \}\par
71 \par
72         {\cf19 if}(priority > 0) \par
73         \{\par
74             bytes_freq[byte_index] = 0; {\cf20 //zera a frequencia na lista de frequencia}\par
75             {\cf18 unsigned} {\cf18 char} {\cf18 byte} = byte_index; {\cf20 //byte recebe o byte que tem maior frequencia}\par
76             enqueue(queue, NULL, NULL, {\cf18 byte}, priority); {\cf20 //enfileira o byte de maior frequencia}\par
77         \}\par
78     \}\par
79 \}\par
}
}
{\xe \v enqueue\:compress.c}
{\xe \v compress.c\:enqueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void enqueue ({\b node} **  {\i queue}, {\b node} *  {\i left}, {\b node} *  {\i right}, unsigned char  {\i byte}, int  {\i priority})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5 \{\par
6     node *new_node = (node*) malloc({\cf17 sizeof}(node)); {\cf20 //aloca na mem\'F3ria espa\'E7o para new_node}\par
7     data *new_data = (data*) malloc({\cf17 sizeof}(data)); {\cf20 //aloca na mem\'F3ria espa\'E7o para new_data}\par
8     new_data->byte = byte; {\cf20 //new_data->byte recebe o par\'E2metro byte }\par
9     new_data->frequency = priority; {\cf20 //new_data->frequency recebe o parametro prioridade}\par
10     new_node->data = new_data; {\cf20 //new_node->data aponta para new_data}\par
11     new_node->left = left; {\cf20 //new_node->left recebe o parametro left}\par
12     new_node->right = right; {\cf20 //new_node->right recebe o parametro right}\par
13 \par
14     {\cf19 if}(left == NULL && right == NULL) {\cf20 //a inser\'E7\'E3o est\'E1 ocorrendo na cria\'E7\'E3o fila de prioridade}\par
15     \{\par
16         new_node->next = *queue;\par
17         *queue = new_node;\par
18     \}\par
19     {\cf19 else} {\cf20 //enfileirando durante a cria\'E7ao da \'E1rvore}\par
20     \{\par
21         node *current = *queue;\par
22         node *previous = NULL;\par
23         \par
24         {\cf19 while} (current != NULL && ((data*)current->data)->frequency < new_data->frequency)\par
25         \{\par
26             previous = current;\par
27             current = current->next;\par
28         \}\par
29         \par
30         new_node->next = current;\par
31 \par
32         {\cf19 if} (previous == NULL)\par
33         \{\par
34             {\cf20 // Se o novo n\'F3 for o primeiro da fila}\par
35             *queue = new_node;\par
36         \}\par
37         {\cf19 else}\par
38         \{\par
39             {\cf20 // Se o novo n\'F3 for inserido no meio ou no fim da fila}\par
40             previous->next = new_node;\par
41         \}\par
42     \}\par
43 \}\par
}
}
{\xe \v get_tree_size\:compress.c}
{\xe \v compress.c\:get_tree_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void get_tree_size ({\b node} *  {\i root}, int *  {\i size})}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 116 \{\par
117     {\cf19 if} (root != NULL) \par
118     \{\par
119         (*size)++;\par
120         get_tree_size(root->left, size);\par
121         get_tree_size(root->right, size);\par
122     \}\par
123 \}\par
}
}
{\xe \v int_to_byte\:compress.c}
{\xe \v compress.c\:int_to_byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void int_to_byte (int  {\i tree_size}, int  {\i trash_size}, unsigned char  {\i trash_tree_size}[2])}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 126 \{\par
127     trash_tree_size[0] = {\cf23 '\\0'};\par
128     trash_tree_size[1] = {\cf23 '\\0'};\par
129   \par
130     trash_tree_size[0] = trash_tree_size[0] | (trash_size << 5); {\cf20 //escreve nos tres primeiros bits do array o valor de trash_size}\par
131 \par
132     trash_tree_size[0] = trash_tree_size[0] | (tree_size >> 8); {\cf20 //escreve nos bits restantes de trash_tree_size[0] os bits 12 a 8}\par
133     trash_tree_size[1] = trash_tree_size[1] | (tree_size); {\cf20 //escreve os bits de }\par
134 \}\par
}
}
{\xe \v read_bytes\:compress.c}
{\xe \v compress.c\:read_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_bytes (int *  {\i bytes_freq}, FILE *  {\i input})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46 \{  \par
47     {\cf19 while}(1)\par
48     \{\par
49         {\cf18 unsigned} {\cf18 char} byte;\par
50         fread(&{\cf18 byte}, 1, 1, input); {\cf20 // l\'EA 1 byte do arquivo e armazena na vari\'E1vel byte}\par
51         {\cf19 if} (feof(input)) {\cf19 return}; {\cf20 // se o arquivo acabou sai do loop;}\par
52         {\cf18 int} i = byte;\par
53         bytes_freq[i] += 1; {\cf20 //soma 1 na frequencia do byte lido}\par
54     \}\par
55 \}\par
}
}
{\xe \v remap\:compress.c}
{\xe \v compress.c\:remap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void remap ({\b node} *  {\i root}, {\b dictionary}  {\i bytes_map}[256], unsigned long  {\i new_symbol}, int  {\i i}, int  {\i bit})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 184 \{\par
185     {\cf19 if} (root != NULL)\par
186     \{\par
187         {\cf19 if} (i == 1)\par
188         \{\par
189             {\cf18 unsigned} {\cf18 long} mask = 1UL << bit;\par
190             new_symbol = new_symbol | mask;\par
191         \}\par
192         \par
193         {\cf19 if}(root->left == NULL && root->right == NULL)\par
194         \{\par
195             {\cf18 int} i = ((data*)root->data)->byte;\par
196             bytes_map[i].symbol_size = (8*{\cf17 sizeof}({\cf18 unsigned} long)) - bit;\par
197             bytes_map[i].symbol = new_symbol >> bit;\par
198         \}\par
199         remap(root->left, bytes_map, new_symbol, 0, bit-1);\par
200         remap(root->right, bytes_map, new_symbol, 1, bit-1);\par
201     \}\par
202 \}\par
}
}
{\xe \v write_pre_order_tree\:compress.c}
{\xe \v compress.c\:write_pre_order_tree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_pre_order_tree ({\b node} *  {\i root}, FILE *  {\i output})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 100 \{\par
101     {\cf19 if} (root != NULL) {\cf20 //funciona como a fun\'E7ao padr\'E3o para imprimir em pr\'E9-ordem com a altera\'E7ao para escrever o byte no arquivo de sa\'EDda}\par
102     \{\par
103         {\cf19 if}(root->left == NULL && root->right == NULL) \par
104         \{\par
105             {\cf18 unsigned} {\cf18 char} flag = 92;\par
106             {\cf19 if} (((data*)root->data)->byte == 42 || ((data*)root->data)->byte == 92)\par
107             fwrite(&flag, 1, 1,output);\par
108         \}\par
109         fwrite(&(((data*)root->data)->byte), 1, 1,output);\par
110         write_pre_order_tree(root->left, output);\par
111         write_pre_order_tree(root->right, output);\par
112     \}\par
113 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo c\'F3digo/compress.h\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/compress.h}
{\xe \v c\'F3digo/compress.h}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "common.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enqueue} ({\b node} **queue, {\b node} *left, {\b node} *right, unsigned char byte, int priority)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_bytes} (int *bytes_freq, FILE *input)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_priority_queue} ({\b node} **queue, int *bytes_freq)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_huffman_tree} ({\b node} **queue)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_pre_order_tree} ({\b node} *root, FILE *output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b get_tree_size} ({\b node} *root, int *size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b int_to_byte} (int tree_size, int trash_size, unsigned char trash_tree_size[2])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b compress} ({\b dictionary} bytes_remap[256], {\b node} *root, FILE *input, FILE *ouput)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b remap} ({\b node} *root, {\b dictionary} bytes_map[256], unsigned long new_symbol, int i, int bit)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v compress\:compress.h}
{\xe \v compress.h\:compress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void compress ({\b dictionary}  {\i bytes_remap}[256], {\b node} *  {\i root}, FILE *  {\i input}, FILE *  {\i ouput})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 137 \{\par
138     {\cf18 unsigned} {\cf18 char} new_byte = {\cf23 '\\0'}, original_byte;\par
139     {\cf18 short} free_bits = 8, new_symbol_size=0;\par
140     dictionary new_symbol;\par
141     fwrite(&new_byte, 1, 2, output); {\cf20 //deixa dois bytes livres no come\'E7o de output para as informa\'E7\'F5es acerca do tamanho do lixo e da \'E1rvore.}\par
142     write_pre_order_tree(root, output); {\cf20 //escreve os bytes da \'E1rvore em pr\'E9 ordem}\par
143     \par
144     {\cf20 //loop para compactar os arquivos com os novos simbolos    }\par
145     {\cf19 while}(1) \par
146     \{\par
147         {\cf19 if}(new_symbol_size == 0 && !(feof(input)))\par
148         \{\par
149             fread(&original_byte, 1, 1, input); {\cf20 //l\'EA um byte do arquivo de entrada e salva ele em original_byte}\par
150             new_symbol = bytes_map[original_byte];\par
151             new_symbol_size = new_symbol.symbol_size;\par
152         \}\par
153 \par
154         {\cf19 if}(!feof(input) && free_bits == 0) {\cf20 //quando esgota os bits livres de new_byte escreve ele no arquivo e reinicia para escrever o resto do new_symbol.byte}\par
155         \{\par
156             fwrite(&new_byte, 1, 1, output);\par
157             new_byte = {\cf23 '\\0'};\par
158             free_bits = 8;\par
159         \}\par
160         {\cf19 else} {\cf19 if}(feof(input))\par
161         \{\par
162             fwrite(&new_byte, 1, 1, output);\par
163             {\cf19 break};\par
164         \}\par
165 \par
166         {\cf19 if}(new_symbol.symbol & (1UL << (new_symbol_size-1)))\par
167         \{\par
168             new_byte = set_bit(new_byte, free_bits-1);\par
169         \}\par
170 \par
171         free_bits--;\par
172         new_symbol_size--;\par
173     \}\par
174     \par
175     {\cf18 unsigned} {\cf18 char} trash_tree_size[2] = \{{\cf23 '\\0'}\};\par
176     {\cf18 int} tree_size = 0;\par
177     get_tree_size(root, &tree_size);\par
178     int_to_byte(tree_size, free_bits, trash_tree_size);\par
179     fseek(output, 0, SEEK_SET);\par
180     fwrite(trash_tree_size, 1, 2, output);\par
181 \}\par
}
}
{\xe \v create_huffman_tree\:compress.h}
{\xe \v compress.h\:create_huffman_tree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_huffman_tree ({\b node} **  {\i queue})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 82 \{\par
83     {\cf19 while} ((*queue)->next != NULL) {\cf20 //navega na fila para transformar ela em \'E1rvore}\par
84     \{\par
85         {\cf20 //pega dois elementos de menor prioridade}\par
86         {\cf18 int} priority;\par
87         node *left = *queue;\par
88         *queue = (*queue)->next;\par
89         node *right = *queue;\par
90         *queue = (*queue)->next;\par
91         \par
92         {\cf17 struct }data *left_data = (data*)left->data;\par
93         {\cf17 struct }data *right_data = (data*)right->data;\par
94 \par
95         priority = left_data->frequency + right_data->frequency; {\cf20 //a frequencia do n\'F3 pai ser\'E1 a soma da frequencia dos dois n\'F3s filhos}\par
96         enqueue(queue, left, right, {\cf23 '*'}, priority); {\cf20 //cria um n\'F3 pai com os filhos sendo os dois menores, remove eles da fila e enfileira o n\'F3 pai}\par
97     \}\par
98 \}\par
}
}
{\xe \v create_priority_queue\:compress.h}
{\xe \v compress.h\:create_priority_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void create_priority_queue ({\b node} **  {\i queue}, int *  {\i bytes_freq})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58 \{\par
59     {\cf18 int} i, j;\par
60     {\cf19 for}(i=0; i<256; i++) {\cf20 //percorre a lista de frequencias 256 vezes (a quantidade de bytes poss\'EDveis)}\par
61     \{\par
62         {\cf18 int} priority=0, byte_index;\par
63         {\cf19 for}(j=0; j<256; j++) {\cf20 //percorre o a lista de frequencia dos bytes procurando a maior frequencia}\par
64         \{\par
65             {\cf19 if}(bytes_freq[j] >= priority && bytes_freq[j] > 0)\par
66             \{\par
67                 byte_index = j;\par
68                 priority = bytes_freq[j];\par
69             \}\par
70         \}\par
71 \par
72         {\cf19 if}(priority > 0) \par
73         \{\par
74             bytes_freq[byte_index] = 0; {\cf20 //zera a frequencia na lista de frequencia}\par
75             {\cf18 unsigned} {\cf18 char} {\cf18 byte} = byte_index; {\cf20 //byte recebe o byte que tem maior frequencia}\par
76             enqueue(queue, NULL, NULL, {\cf18 byte}, priority); {\cf20 //enfileira o byte de maior frequencia}\par
77         \}\par
78     \}\par
79 \}\par
}
}
{\xe \v enqueue\:compress.h}
{\xe \v compress.h\:enqueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void enqueue ({\b node} **  {\i queue}, {\b node} *  {\i left}, {\b node} *  {\i right}, unsigned char  {\i byte}, int  {\i priority})}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5 \{\par
6     node *new_node = (node*) malloc({\cf17 sizeof}(node)); {\cf20 //aloca na mem\'F3ria espa\'E7o para new_node}\par
7     data *new_data = (data*) malloc({\cf17 sizeof}(data)); {\cf20 //aloca na mem\'F3ria espa\'E7o para new_data}\par
8     new_data->byte = byte; {\cf20 //new_data->byte recebe o par\'E2metro byte }\par
9     new_data->frequency = priority; {\cf20 //new_data->frequency recebe o parametro prioridade}\par
10     new_node->data = new_data; {\cf20 //new_node->data aponta para new_data}\par
11     new_node->left = left; {\cf20 //new_node->left recebe o parametro left}\par
12     new_node->right = right; {\cf20 //new_node->right recebe o parametro right}\par
13 \par
14     {\cf19 if}(left == NULL && right == NULL) {\cf20 //a inser\'E7\'E3o est\'E1 ocorrendo na cria\'E7\'E3o fila de prioridade}\par
15     \{\par
16         new_node->next = *queue;\par
17         *queue = new_node;\par
18     \}\par
19     {\cf19 else} {\cf20 //enfileirando durante a cria\'E7ao da \'E1rvore}\par
20     \{\par
21         node *current = *queue;\par
22         node *previous = NULL;\par
23         \par
24         {\cf19 while} (current != NULL && ((data*)current->data)->frequency < new_data->frequency)\par
25         \{\par
26             previous = current;\par
27             current = current->next;\par
28         \}\par
29         \par
30         new_node->next = current;\par
31 \par
32         {\cf19 if} (previous == NULL)\par
33         \{\par
34             {\cf20 // Se o novo n\'F3 for o primeiro da fila}\par
35             *queue = new_node;\par
36         \}\par
37         {\cf19 else}\par
38         \{\par
39             {\cf20 // Se o novo n\'F3 for inserido no meio ou no fim da fila}\par
40             previous->next = new_node;\par
41         \}\par
42     \}\par
43 \}\par
}
}
{\xe \v get_tree_size\:compress.h}
{\xe \v compress.h\:get_tree_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void get_tree_size ({\b node} *  {\i root}, int *  {\i size})}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 116 \{\par
117     {\cf19 if} (root != NULL) \par
118     \{\par
119         (*size)++;\par
120         get_tree_size(root->left, size);\par
121         get_tree_size(root->right, size);\par
122     \}\par
123 \}\par
}
}
{\xe \v int_to_byte\:compress.h}
{\xe \v compress.h\:int_to_byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void int_to_byte (int  {\i tree_size}, int  {\i trash_size}, unsigned char  {\i trash_tree_size}[2])}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 126 \{\par
127     trash_tree_size[0] = {\cf23 '\\0'};\par
128     trash_tree_size[1] = {\cf23 '\\0'};\par
129   \par
130     trash_tree_size[0] = trash_tree_size[0] | (trash_size << 5); {\cf20 //escreve nos tres primeiros bits do array o valor de trash_size}\par
131 \par
132     trash_tree_size[0] = trash_tree_size[0] | (tree_size >> 8); {\cf20 //escreve nos bits restantes de trash_tree_size[0] os bits 12 a 8}\par
133     trash_tree_size[1] = trash_tree_size[1] | (tree_size); {\cf20 //escreve os bits de }\par
134 \}\par
}
}
{\xe \v read_bytes\:compress.h}
{\xe \v compress.h\:read_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_bytes (int *  {\i bytes_freq}, FILE *  {\i input})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46 \{  \par
47     {\cf19 while}(1)\par
48     \{\par
49         {\cf18 unsigned} {\cf18 char} byte;\par
50         fread(&{\cf18 byte}, 1, 1, input); {\cf20 // l\'EA 1 byte do arquivo e armazena na vari\'E1vel byte}\par
51         {\cf19 if} (feof(input)) {\cf19 return}; {\cf20 // se o arquivo acabou sai do loop;}\par
52         {\cf18 int} i = byte;\par
53         bytes_freq[i] += 1; {\cf20 //soma 1 na frequencia do byte lido}\par
54     \}\par
55 \}\par
}
}
{\xe \v remap\:compress.h}
{\xe \v compress.h\:remap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void remap ({\b node} *  {\i root}, {\b dictionary}  {\i bytes_map}[256], unsigned long  {\i new_symbol}, int  {\i i}, int  {\i bit})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 184 \{\par
185     {\cf19 if} (root != NULL)\par
186     \{\par
187         {\cf19 if} (i == 1)\par
188         \{\par
189             {\cf18 unsigned} {\cf18 long} mask = 1UL << bit;\par
190             new_symbol = new_symbol | mask;\par
191         \}\par
192         \par
193         {\cf19 if}(root->left == NULL && root->right == NULL)\par
194         \{\par
195             {\cf18 int} i = ((data*)root->data)->byte;\par
196             bytes_map[i].symbol_size = (8*{\cf17 sizeof}({\cf18 unsigned} long)) - bit;\par
197             bytes_map[i].symbol = new_symbol >> bit;\par
198         \}\par
199         remap(root->left, bytes_map, new_symbol, 0, bit-1);\par
200         remap(root->right, bytes_map, new_symbol, 1, bit-1);\par
201     \}\par
202 \}\par
}
}
{\xe \v write_pre_order_tree\:compress.h}
{\xe \v compress.h\:write_pre_order_tree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_pre_order_tree ({\b node} *  {\i root}, FILE *  {\i output})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 100 \{\par
101     {\cf19 if} (root != NULL) {\cf20 //funciona como a fun\'E7ao padr\'E3o para imprimir em pr\'E9-ordem com a altera\'E7ao para escrever o byte no arquivo de sa\'EDda}\par
102     \{\par
103         {\cf19 if}(root->left == NULL && root->right == NULL) \par
104         \{\par
105             {\cf18 unsigned} {\cf18 char} flag = 92;\par
106             {\cf19 if} (((data*)root->data)->byte == 42 || ((data*)root->data)->byte == 92)\par
107             fwrite(&flag, 1, 1,output);\par
108         \}\par
109         fwrite(&(((data*)root->data)->byte), 1, 1,output);\par
110         write_pre_order_tree(root->left, output);\par
111         write_pre_order_tree(root->right, output);\par
112     \}\par
113 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
compress.h\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/compress.h}
{\xe \v c\'F3digo/compress.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef COMPRESS_H_INCLUDED}\par
2 {\cf21 #define COMPRESS_H_INCLUDED}\par
3 \par
4 {\cf21 #include <stdio.h>}\par
5 {\cf21 #include <stdlib.h>}\par
6 {\cf21 #include <stdbool.h>}\par
7 {\cf21 #include "common.h"}\par
8 \par
9 \par
10 {\cf18 void} enqueue(node **queue, node *left, node *right, {\cf18 unsigned} {\cf18 char} {\cf18 byte}, {\cf18 int} priority);\par
11 {\cf18 void} read_bytes({\cf18 int} *bytes_freq, FILE *input); \par
12 {\cf18 void} create_priority_queue(node **queue, {\cf18 int} *bytes_freq);\par
13 {\cf18 void} create_huffman_tree(node **queue);\par
14 {\cf18 void} write_pre_order_tree(node *root, FILE *output);\par
15 {\cf18 void} get_tree_size(node *root, {\cf18 int} *size);\par
16 {\cf18 void} int_to_byte({\cf18 int} tree_size, {\cf18 int} trash_size, {\cf18 unsigned} {\cf18 char} trash_tree_size[2]);\par
17 {\cf18 void} compress(dictionary bytes_remap[256], node *root, FILE *input, FILE *ouput);\par
18 {\cf18 void} remap(node *root, dictionary bytes_map[256], {\cf18 unsigned} {\cf18 long} new_symbol, {\cf18 int} i, {\cf18 int} bit);\par
19 \par
20 {\cf21 #endif }{\cf20 //COMPRESS_H_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo c\'F3digo/main.c\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/main.c}
{\xe \v c\'F3digo/main.c}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "common.h"}\par
{\f2 #include "compress.h"}\par
{\f2 #include "uncompress.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (void )}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7 \{\par
8     {\cf18 char} input_file_name[MAX_FNAME+1];\par
9     {\cf18 int} operation;\par
10     FILE *input, *output;\par
11     \par
12     printf({\cf22 "DIGITE A OPERACAO DESEJADA\\n1-COMPACTAR\\t2-DESCOMPACTAR\\n"});\par
13     scanf({\cf22 "%d"}, &operation);\par
14     \par
15     {\cf18 int} c;\par
16     {\cf19 while} ((c = getchar()) != {\cf23 '\\n'} && c != EOF) \{ \}\par
17 \par
18     printf({\cf22 "DIGITE O NOME DO ARQUIVO:\\n"});\par
19     fgets(input_file_name, MAX_FNAME, stdin);\par
20 \par
21     {\cf18 size_t} len = strlen(input_file_name);\par
22     {\cf19 if} (len > 0 && input_file_name[len-1] == {\cf23 '\\n'}) \{\par
23         input_file_name[len-1] = {\cf23 '\\0'};\par
24     \}\par
25 \par
26     input = fopen(input_file_name, {\cf22 "rb"});\par
27     output = create_output_file(input_file_name, operation);\par
28 \par
29     node *queue = NULL;\par
30 \par
31     {\cf19 switch} (operation)\par
32     \{\par
33         {\cf19 case} COMPRESS:\par
34             {\cf18 int} bytes_freq[256] = \{0\}; \par
35             dictionary bytes_remap[256];\par
36             {\cf19 for}({\cf18 int} i = 0; i<256; i++)\par
37             \{\par
38                 bytes_remap[i].symbol_size = 0;\par
39                 bytes_remap[i].symbol = 0UL;\par
40             \}\par
41             read_bytes(bytes_freq, input);\par
42             fseek(input, 0, SEEK_SET); \par
43             create_priority_queue(&queue, bytes_freq);\par
44             create_huffman_tree(&queue);\par
45             remap(queue, bytes_remap, 0UL, 0, (8*{\cf17 sizeof}({\cf18 unsigned} {\cf18 long})));\par
46             compress(bytes_remap, queue, input, output);\par
47             printf({\cf22 "\\nO ARQUIVO \\x1b[31m%S\\x1b[0m FOI COMPACTADO COM SUCESSO\\n"}, input_file_name);\par
48             {\cf19 break};\par
49         {\cf19 case} UNCOMPRESS:\par
50             {\cf18 int} trash_size = 0, tree_size = 0;\par
51             {\cf18 unsigned} {\cf18 long} file_size;\par
52             get_file_size(input, &file_size);\par
53             get_trash_tree_size(input, &trash_size, &tree_size);\par
54             build_tree(&queue, input, tree_size);\par
55             uncompress(queue, input, output, trash_size, (file_size-tree_size-2));\par
56             printf({\cf22 "\\nO ARQUIVO FOI DESCOMPACTADO COM SUCESSO\\n"}, input_file_name);\par
57             {\cf19 break};\par
58     \}\par
59     free(queue);\par
60     fclose(input);\par
61     fclose(output);\par
62 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo c\'F3digo/uncompress.c\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/uncompress.c}
{\xe \v c\'F3digo/uncompress.c}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "common.h"}\par
{\f2 #include "uncompress.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b build_tree} ({\b node} **root, FILE *input, int tree_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b get_trash_tree_size} (FILE *input, int *trash_size, int *tree_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uncompress} ({\b node} *root, FILE *input, FILE *output, int trash_size, unsigned long file_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b get_file_size} (FILE *input, unsigned long *file_size)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v build_tree\:uncompress.c}
{\xe \v uncompress.c\:build_tree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void build_tree ({\b node} **  {\i root}, FILE *  {\i input}, int  {\i tree_size})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5 \{\par
6     {\cf19 if} (tree_size <= 0) {\cf19 return}; \par
7     tree_size--;\par
8 \par
9     {\cf18 unsigned} {\cf18 char} byte;\par
10     {\cf18 int} n = fread(&{\cf18 byte}, 1, 1, input);\par
11 \par
12     {\cf19 if} ({\cf18 byte} == PO_TREE_SCAPE) n += fread(&{\cf18 byte}, 1, 1, input); {\cf20 //PO_TREE_SCAPE = BYTE 5C}\par
13 \par
14     node *new_node = (node*) malloc({\cf17 sizeof}(node));\par
15     data *new_data = (data*) malloc({\cf17 sizeof}(data));\par
16     new_data->byte = byte;\par
17     new_data->frequency = 0;\par
18     new_node->data = new_data;\par
19     new_node->left = NULL;\par
20     new_node->right = NULL;\par
21 \par
22     {\cf19 if} ({\cf18 byte} == {\cf23 '*'} && n == 1) {\cf20 //n\'F3 interno}\par
23     \{\par
24         build_tree(&(new_node->left), input, tree_size);\par
25         build_tree(&(new_node->right), input, tree_size);\par
26     \}\par
27 \par
28     *root = new_node;\par
29 \}\par
}
}
{\xe \v get_file_size\:uncompress.c}
{\xe \v uncompress.c\:get_file_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void get_file_size (FILE *  {\i input}, unsigned long *  {\i file_size})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 73 \{\par
74     fseek(input, 0, SEEK_END);\par
75 \par
76     *file_size = ftell(input);\par
77 \par
78     fseek(input, 0, SEEK_SET);\par
79 \}\par
}
}
{\xe \v get_trash_tree_size\:uncompress.c}
{\xe \v uncompress.c\:get_trash_tree_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void get_trash_tree_size (FILE *  {\i input}, int *  {\i trash_size}, int *  {\i tree_size})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32 \{\par
33     {\cf18 unsigned} {\cf18 char} trash_tree_size[2] = \{{\cf23 '\\0'}\};\par
34     fread(trash_tree_size, 1, 2, input);\par
35     \par
36     *trash_size =  (trash_tree_size[0] >> 5) & 7;\par
37     *tree_size =  ((trash_tree_size[0] & 31) << 8) | trash_tree_size[1];\par
38 \}\par
}
}
{\xe \v uncompress\:uncompress.c}
{\xe \v uncompress.c\:uncompress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uncompress ({\b node} *  {\i root}, FILE *  {\i input}, FILE *  {\i output}, int  {\i trash_size}, unsigned long  {\i file_size})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41 \{\par
42     {\cf18 unsigned} {\cf18 long} read_bytes = 1UL;\par
43     {\cf18 int} bit = 7, is_last_byte = 0;\par
44     {\cf18 unsigned} {\cf18 char} byte;\par
45     fread(&{\cf18 byte}, 1, 1, input);\par
46     node *temp_root = root;\par
47 \par
48     {\cf19 while}(1)\par
49     \{\par
50         temp_root = root;\par
51 \par
52         {\cf19 while}(temp_root->left != NULL && temp_root->right != NULL)\par
53         \{\par
54             {\cf19 if}(is_bit_set({\cf18 byte}, bit)) temp_root = temp_root->right;\par
55             {\cf19 else} temp_root = temp_root->left;\par
56             bit--;\par
57 \par
58             {\cf19 if}(bit < 0)\par
59             \{\par
60                 bit = 7;\par
61                 fread(&{\cf18 byte}, 1, 1, input);\par
62                 read_bytes++;\par
63                 is_last_byte = (read_bytes == file_size);\par
64             \}\par
65         \}\par
66         fwrite((&((data*)temp_root->data)->byte), 1, 1, output);\par
67         \par
68         {\cf19 if}(is_last_byte && bit <= trash_size) {\cf19 break};\par
69     \}\par
70 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo c\'F3digo/uncompress.h\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/uncompress.h}
{\xe \v c\'F3digo/uncompress.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "common.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b build_tree} ({\b node} **root, FILE *input, int tree_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b get_trash_tree_size} (FILE *input, int *trash_size, int *tree_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uncompress} ({\b node} *root, FILE *input, FILE *output, int trash_size, unsigned long file_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b get_file_size} (FILE *input, unsigned long *file_size)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v build_tree\:uncompress.h}
{\xe \v uncompress.h\:build_tree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void build_tree ({\b node} **  {\i root}, FILE *  {\i input}, int  {\i tree_size})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5 \{\par
6     {\cf19 if} (tree_size <= 0) {\cf19 return}; \par
7     tree_size--;\par
8 \par
9     {\cf18 unsigned} {\cf18 char} byte;\par
10     {\cf18 int} n = fread(&{\cf18 byte}, 1, 1, input);\par
11 \par
12     {\cf19 if} ({\cf18 byte} == PO_TREE_SCAPE) n += fread(&{\cf18 byte}, 1, 1, input); {\cf20 //PO_TREE_SCAPE = BYTE 5C}\par
13 \par
14     node *new_node = (node*) malloc({\cf17 sizeof}(node));\par
15     data *new_data = (data*) malloc({\cf17 sizeof}(data));\par
16     new_data->byte = byte;\par
17     new_data->frequency = 0;\par
18     new_node->data = new_data;\par
19     new_node->left = NULL;\par
20     new_node->right = NULL;\par
21 \par
22     {\cf19 if} ({\cf18 byte} == {\cf23 '*'} && n == 1) {\cf20 //n\'F3 interno}\par
23     \{\par
24         build_tree(&(new_node->left), input, tree_size);\par
25         build_tree(&(new_node->right), input, tree_size);\par
26     \}\par
27 \par
28     *root = new_node;\par
29 \}\par
}
}
{\xe \v get_file_size\:uncompress.h}
{\xe \v uncompress.h\:get_file_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void get_file_size (FILE *  {\i input}, unsigned long *  {\i file_size})}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 73 \{\par
74     fseek(input, 0, SEEK_END);\par
75 \par
76     *file_size = ftell(input);\par
77 \par
78     fseek(input, 0, SEEK_SET);\par
79 \}\par
}
}
{\xe \v get_trash_tree_size\:uncompress.h}
{\xe \v uncompress.h\:get_trash_tree_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void get_trash_tree_size (FILE *  {\i input}, int *  {\i trash_size}, int *  {\i tree_size})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32 \{\par
33     {\cf18 unsigned} {\cf18 char} trash_tree_size[2] = \{{\cf23 '\\0'}\};\par
34     fread(trash_tree_size, 1, 2, input);\par
35     \par
36     *trash_size =  (trash_tree_size[0] >> 5) & 7;\par
37     *tree_size =  ((trash_tree_size[0] & 31) << 8) | trash_tree_size[1];\par
38 \}\par
}
}
{\xe \v uncompress\:uncompress.h}
{\xe \v uncompress.h\:uncompress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uncompress ({\b node} *  {\i root}, FILE *  {\i input}, FILE *  {\i output}, int  {\i trash_size}, unsigned long  {\i file_size})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41 \{\par
42     {\cf18 unsigned} {\cf18 long} read_bytes = 1UL;\par
43     {\cf18 int} bit = 7, is_last_byte = 0;\par
44     {\cf18 unsigned} {\cf18 char} byte;\par
45     fread(&{\cf18 byte}, 1, 1, input);\par
46     node *temp_root = root;\par
47 \par
48     {\cf19 while}(1)\par
49     \{\par
50         temp_root = root;\par
51 \par
52         {\cf19 while}(temp_root->left != NULL && temp_root->right != NULL)\par
53         \{\par
54             {\cf19 if}(is_bit_set({\cf18 byte}, bit)) temp_root = temp_root->right;\par
55             {\cf19 else} temp_root = temp_root->left;\par
56             bit--;\par
57 \par
58             {\cf19 if}(bit < 0)\par
59             \{\par
60                 bit = 7;\par
61                 fread(&{\cf18 byte}, 1, 1, input);\par
62                 read_bytes++;\par
63                 is_last_byte = (read_bytes == file_size);\par
64             \}\par
65         \}\par
66         fwrite((&((data*)temp_root->data)->byte), 1, 1, output);\par
67         \par
68         {\cf19 if}(is_last_byte && bit <= trash_size) {\cf19 break};\par
69     \}\par
70 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
uncompress.h\par \pard\plain 
{\tc\tcl2 \v c\'F3digo/uncompress.h}
{\xe \v c\'F3digo/uncompress.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef UNCOMPRESS_H_INCLUDED}\par
2 {\cf21 #define UNCOMPRESS_H_INCLUDED}\par
3 {\cf21 #include "common.h"}\par
4 \par
5     {\cf18 void} build_tree(node **root, FILE *input, {\cf18 int} tree_size);\par
6     {\cf18 void} get_trash_tree_size(FILE *input, {\cf18 int} *trash_size, {\cf18 int} *tree_size);\par
7     {\cf18 void} uncompress(node *root, FILE *input, FILE *output, {\cf18 int} trash_size, {\cf18 unsigned} {\cf18 long} file_size);\par
8     {\cf18 void} get_file_size(FILE *input, {\cf18 unsigned} {\cf18 long} *file_size);\par
9 \par
10 {\cf21 #endif }{\cf20 //UNCOMPRESS_H_INCLUDED}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par 
\pard\plain 
{\tc \v Sum\'E1rio}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
